import{_ as s,f as t}from"../index.mjs";const a={type:"article",title:"Package-First Philosophy",description:"A year ago, we were facing a common challenge: a sprawling codebase where everything was interconnected. Fixing one issue often broke something else. Refactors felt like high-stakes operations. Code reviews were slow and confusing because no one was clear on ownership. It was a familiar problem, and it was draining.",tags:["monorepo","package-first","software-development","team-culture"],url:"/articles/2025-07-02-package-first-philosophy",canonicalUrl:"https://znck.dev/articles/2025-07-02-package-first-philosophy",author:"Rahul Kadyan",published:"2025-07-02T00:00:00.000Z",frontmatter:{tags:["monorepo","package-first","software-development","team-culture"],collection:"Journey to the monorepo"},socialImage:null};a.published=new Date(a.published);const o={};function n(i,e,r,c,l,d){return e[0]||(e[0]=t('<h1 id="package-first-philosophy" class="moss-anchored-heading">Package-First Philosophy<a tabindex="-1" class="moss-anchor-container" href="#package-first-philosophy"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Package-First Philosophy</span></a></h1><p>A year ago, we were facing a common challenge: a sprawling codebase where everything was interconnected. Fixing one issue often broke something else. Refactors felt like high-stakes operations. Code reviews were slow and confusing because no one was clear on ownership. It was a familiar problem, and it was draining.</p><p>We decided to change that—not just with better tooling, but by reshaping the way we thought about code.</p><p>So we made a simple bet: <strong>make packages the center of the universe</strong>.</p><h2 id="why-package-first" class="moss-anchored-heading">Why Package-First?<a tabindex="-1" class="moss-anchor-container" href="#why-package-first"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Why Package-First?</span></a></h2><p>If something deserves a name, it deserves a package.</p><p>In our world, a package is a unit of structure, ownership, and contribution. It owns its code, tests, documentation, and public interface. It’s a contract—not just to the system, but to the team maintaining it.</p><p>This model provides several benefits:</p><ul><li><strong>Isolation</strong>: Changes in one package stay within that package.</li><li><strong>Ownership</strong>: Contributors are responsible for specific, focused units.</li><li><strong>Autonomy</strong>: You don’t need to coordinate across teams to ship new features.</li><li><strong>Composability</strong>: Small components can be combined to create larger systems.</li><li><strong>Focus</strong>: The smaller the surface area, the easier it is to reason about.</li></ul><p>The side effect? Simpler code, fewer arguments, faster reviews, and clearer responsibilities.</p><h2 id="habits-triggers-and-code" class="moss-anchored-heading">Habits, Triggers, and Code<a tabindex="-1" class="moss-anchor-container" href="#habits-triggers-and-code"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Habits, Triggers, and Code</span></a></h2><p>While reading <em>The Power of Habit</em> by Charles Duhigg, one idea stood out: habits are built on cues, routines, and rewards. Change the cue, and the routine often follows.</p><p>That resonated with our experience.</p><p>Once we made it easy to create a new package—just a few keystrokes and a scaffolded module was ready—developers started defaulting to it. The friction was gone. The cue shifted: instead of asking &quot;where should I add this code?&quot;, the new instinct became &quot;should I create a new package for this?&quot;</p><p>The result? A new habit. Modular thinking became automatic. Developers started creating focused packages, with clear interfaces and isolated tests. The reward was immediate: fewer merge conflicts, faster reviews, and a deeper sense of ownership.</p><p>As Duhigg puts it, once a habit loop is established, it reinforces itself. The package-first mindset became that loop.</p><h2 id="enabling-package-first-development" class="moss-anchored-heading">Enabling Package-First Development<a tabindex="-1" class="moss-anchor-container" href="#enabling-package-first-development"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Enabling Package-First Development</span></a></h2><p>Making package creation easy was a game-changer. Teams stopped overloading existing modules and started creating new packages instead. The monolith didn’t shrink, but it became much more understandable.</p><p>We used Nx and pnpm to implement this, but the tools were just the means to an end. Here’s what we focused on:</p><ul><li><strong>Nx generators</strong>: These scaffold fully functional packages for known types—<code>utility</code>, <code>tool</code>, <code>feature</code>, or <code>app</code>. Each package comes with build, test, lint, and documentation preconfigured.</li><li><strong>Ready-to-use packages</strong>: No extra setup required. Just start writing code.</li><li><strong>Explicit public interfaces</strong>: All public interfaces are clearly marked with <code>@public</code>, and we enforce this through tooling.</li></ul><p>As friction disappeared, hesitation followed suit. Developers iterated faster, experimented more, and by default, wrote more modular code.</p><h2 id="metadata-is-ownership" class="moss-anchored-heading">Metadata is Ownership<a tabindex="-1" class="moss-anchor-container" href="#metadata-is-ownership"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Metadata is Ownership</span></a></h2><p>Every package clearly defines its owner, where to file bugs, and what it does. But the real power is in the metadata: the <code>package.json</code> often tells you more than the code itself. It communicates intent, capabilities, and responsibilities—all without opening a single <code>.ts</code> file.</p><p>Here’s how it works:</p><ul><li><strong>Ownership metadata</strong> drives the routing of code reviews, ensuring that the right people are involved.</li><li><strong>Capability metadata</strong> enables feature discovery and helps developers understand what each package is responsible for.</li><li><strong>Dependency metadata</strong> powers impact analysis, letting you know how changes will affect other parts of the codebase.</li></ul><p>This isn’t just documentation—it’s operational infrastructure. By treating packages as self-describing units, we gain confidence across the board, and this structure supports automated tooling and decision-making.</p><h2 id="scale-by-design" class="moss-anchored-heading">Scale by Design<a tabindex="-1" class="moss-anchor-container" href="#scale-by-design"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Scale by Design</span></a></h2><p>When everything is a package:</p><ul><li>Teams onboard faster because they understand exactly where to find and contribute to code.</li><li>Features become portable, easily shared and reused.</li><li>Applications become compositions rather than monolithic systems.</li><li>Dependencies stay local, reducing complexity and risk.</li></ul><p>It’s not magic—it’s just structure. And structure scales.</p><p>In the first six months, we saw over 80 new packages created, many by teams who had never worked in this repo before. That wasn’t just a win for tooling—it was a shift in how people thought about software: small, manageable units, clear contracts, and fast feedback.</p><p>As we leaned further into the package-first model, it reinforced itself. Better structure led to better habits. Better habits led to better software.</p>',32))}const h=s(o,[["render",n],["__file","2025-07-02-package-first-philosophy.md"]]);export{h as default,a as pageData};

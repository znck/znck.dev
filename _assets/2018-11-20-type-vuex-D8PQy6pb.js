import{_ as r,g as p,f as o,a as e,e as l,b as s,w as u,F as d,r as c,o as m}from"../index.mjs";const i="/_assets/1-BnqozjI5.png",h="/_assets/2-BQlXO-Xp.png",y="/_assets/3-Bslfh-Hi.png",g="/_assets/4-BJtctiMc.png",f="/_assets/5-CyV0s8iN.png",x="/_assets/6-DIBqQFA6.gif",w="/_assets/7-M3zxuUol.png",v="/_assets/8-CxNvcxE4.png",b="/_assets/9-ahcXzF5b.png",V="/_assets/10-rVszHpV-.png",T="/_assets/11-DpGttMf7.png",S="/_assets/12-Bks9Zzdt.png",k="/_assets/13-DaHLSGuR.png",n={type:"article",title:"Type Vuex without TypeScript",description:"A practical guide for type checking vuex modules written in JS and getting things done.",tags:["vue","typescript","dx"],url:"/articles/2018-11-20-type-vuex",canonicalUrl:"https://znck.dev/articles/2018-11-20-type-vuex",author:"Rahul Kadyan",published:"2018-11-20T00:00:00.000Z",frontmatter:{published:"2018-11-20T00:00:00.000Z",tags:["vue","typescript","dx"],description:"A practical guide for type checking vuex modules written in JS and getting things done."},socialImage:"../assets/2018-type-vuex/1.png"};n.published=new Date(n.published);n.socialImage=i;const I={};function A(J,t,z,B,D,H){const a=c("tweet");return m(),p(d,null,[t[1]||(t[1]=o('<h1 id="type-vuex-without-typescript" class="moss-anchored-heading">Type Vuex without TypeScript<a tabindex="-1" class="moss-anchor-container" href="#type-vuex-without-typescript"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Type Vuex without TypeScript</span></a></h1><blockquote><p>This is a continuation article to <a href="./2018-type-vue">Type Vue without TypeScript</a>, if you haven’t already read it, I suggest you read that first.</p></blockquote><h2 id="vuex-does-support-types" class="moss-anchored-heading">Vuex does support types!<a tabindex="-1" class="moss-anchor-container" href="#vuex-does-support-types"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Vuex does support types!</span></a></h2><p>The official state management library for Vue does support TypeScript. It provides MutationTree and ActionTree type helpers to get auto-completion and intellisense in mutations and actions.</p><p><img src="'+i+'" alt="Vuex store implementation written in TypeScript"></p><p>We can also get types in JavaScript with JSDoc <code>@type</code> annotation.</p><p><img src="'+h+'" alt="Vuex store implementation written in JavaScript"></p><p>If we use options syntax for creating a store, most of the boilerplate comments are unnecessary.</p><p><img src="'+y+'" alt="Vuex store implementation written in JavaScript using options syntax"></p><p>The TypeScript API for Vuex is limited however. Type checks and intellisense in commit and dispatch are very primitive.</p>',10)),t[2]||(t[2]=e("figure",{"data-type":"image"},[e("div",{stack:"",row:"",wide:""},[e("img",{src:g,alt:"Screenshot: Intellisense in commit methods of vuex store"}),e("img",{src:f,alt:"Screenshot: Intellisense in dispatch methods of vuex store"})]),e("figcaption",null,"Intellisense in commit (left) and dispatch (right) methods of Vuex store")],-1)),t[3]||(t[3]=e("p",null,"As you can see above, we get intellisense to let us know that commit and dispatch take strings as the first argument, but we don’t get a list of registered actions and mutations. There is not much we can do here, with or without TypeScript. However, there are lots of third-party packages trying to get the types right in the Vuex store and modules.",-1)),t[4]||(t[4]=e("p",null,[e("img",{src:x,alt:"Vuex helper packages for TypeScript"})],-1)),t[5]||(t[5]=e("p",null,[s("We won’t be introducing new dependencies to a project only to get the types right, as most people are using just Vuex. However, "),e("a",{href:"//github.com/ktsn/vuex-class"},"vuex-class"),s(", "),e("a",{href:"//github.com/istrib/vuex-typescript"},"vuex-typescript"),s(" and "),e("a",{href:"//github.com/championswimmer/vuex-module-decorators"},"vuex-module-decorators"),s(" are worth mentioning third-party packages assisting Vuex stores.")],-1)),l(a,{id:"1062919689515368448"},{default:u(()=>t[0]||(t[0]=[e("blockquote",null,[e("p",null,[s("All the TypeScript + Vue users out there, what do you use to write Vuex modules and why? — "),e("a",{href:"https://twitter.com/znck0/status/1062919689515368448",target:"_blank",rel:"noopener noreferrer"},"@znck0")])],-1)])),_:1,__:[0]}),t[6]||(t[6]=e("p",null,"The next version of Vuex would be built with an API which plays well with TypeScript.",-1)),t[7]||(t[7]=e("p",null,"We cannot do much with committing mutations and dispatching actions due to limitations in the TypeScript API for Vuex. Though with namespaced modules, we can limit the scope of a store and keep individual store modules comprehendible. However, there is another area of Vuex which can use types and intellisense.",-1)),t[8]||(t[8]=e("h3",{id:"using-vuex-store-in-vue-components",class:"moss-anchored-heading"},[s("Using Vuex Store in Vue components"),e("a",{tabindex:"-1",class:"moss-anchor-container",href:"#using-vuex-store-in-vue-components"},[e("span",{class:"moss-anchor"}),e("span",{class:"sr-only"},"Jump to section titled Using Vuex Store in Vue components")])],-1)),t[9]||(t[9]=e("p",null,"Vuex provides mapState, mapGetters, mapActions and mapMutations helpers to simplify binding store state in Vue components. However, the API is string literals based and sort of impossible to provide types and intellisense.",-1)),t[10]||(t[10]=e("p",null,[e("img",{src:w,alt:"Using Vuex store in Vue component",small:""})],-1)),t[11]||(t[11]=o('<p>This problem is still unsolved in the TypeScript world, and there is not much we can do in the JavaScript world. However, there exists a pattern, and to my knowledge, popularised by <a href="//twitter.com/chrisvfritz">Chris Fritz</a>’s <a href="//github.com/chrisvfritz/vue-enterprise-boilerplate">Enterprise Boilerplate</a> which can be enhanced.</p><h3 id="helpers-pattern-in-vuex" class="moss-anchored-heading">Helpers pattern in Vuex<a tabindex="-1" class="moss-anchor-container" href="#helpers-pattern-in-vuex"><span class="moss-anchor"></span><span class="sr-only">Jump to section titled Helpers pattern in Vuex</span></a></h3><p>According to Chris’ helper pattern, we create a store helper file, and all the mapXxx method calls of Vuex store usages are collected here. We can create contextual groups of computed and methods properties which can be added to components directly.</p>',3)),t[12]||(t[12]=e("p",null,[e("img",{src:v,alt:"Vuex helper pattern example",small:""})],-1)),t[13]||(t[13]=e("p",null,"Other than providing possibilities of intellisense enhancements, this pattern reduces the surface area affected by Vuex in an application. Let’s say if Vuex introduces breaking changes then we have to update only helpers.js file. Also, it reduces code footprint and increases reuse of mapXxx across packages.",-1)),t[14]||(t[14]=e("h3",{id:"intellisense-for-vuex-stores-written-with-helpers-pattern",class:"moss-anchored-heading"},[s("Intellisense for Vuex stores written with helpers pattern"),e("a",{tabindex:"-1",class:"moss-anchor-container",href:"#intellisense-for-vuex-stores-written-with-helpers-pattern"},[e("span",{class:"moss-anchor"}),e("span",{class:"sr-only"},"Jump to section titled Intellisense for Vuex stores written with helpers pattern")])],-1)),t[15]||(t[15]=e("p",null,"We can annotate exports from helpers in such a way that we get better intellisense when used in the component.",-1)),t[16]||(t[16]=e("p",null,"e.g., In the following code snippet, addTodo method accepts a text argument of type string.",-1)),t[17]||(t[17]=e("p",null,[e("img",{src:b,alt:"Intellisense in Vuex mapped methods",small:""})],-1)),t[18]||(t[18]=e("p",null,"Intellisense in above snippet is not automatic; it requires some type-casts using JSDocs. e.g., There should be addTodo method on the type of todosMethods object exported by helpers module. So with a type definition using @typedef, we can name this type TodoMethods.",-1)),t[19]||(t[19]=e("p",null,[e("img",{src:V,alt:"Vuex helpers with JSDoc type annotations",small:""})],-1)),t[20]||(t[20]=e("p",null,[s("In the above type definition, TodoMethods has a property addTodo of type function. To define a function type, we can use a double curly bracket, similar to Vue’s moustache syntax ("),e("code",null,"{{ ... }}"),s("). In the double curly brackets, we add types in format (param: type): return-type and hence for a function accepting one string argument, we have "),e("code",null,"{{ (text: string): void }}"),s(". As we know an action always returns a promise, we can augment addTodo method type to "),e("code",null,"{{ (text: string): Promise<void> }}"),s(". Similarly, we can add a type to computed properties, but as required by API, these should be functions.")],-1)),t[21]||(t[21]=e("p",null,[e("img",{src:T,alt:"VS Code Type Inference",small:""})],-1)),t[22]||(t[22]=e("p",null,[s("This approach is a little brittle as any changes in properties used in "),e("code",null,"mapXxx"),s(" could potentially effect JSDoc type definitions. Also, any new property added to mapXxx functions requires type definition to be added to the corresponding typedef.")],-1)),t[23]||(t[23]=e("p",null,[s("Also, if you noticed the type of "),e("code",null,"completedTodos"),s(" in the above snippet, it says "),e("code",null,"any[]"),s(". It’s due to a bug in VS Code which does not show imported types correctly.")],-1)),t[24]||(t[24]=e("p",null,[e("img",{src:S,alt:"JSDoc type hint"})],-1)),t[25]||(t[25]=e("p",null,[e("img",{src:k,alt:"Bug in VS Code which fails to display imported files (outdated)",small:""})],-1)),t[26]||(t[26]=e("p",null,[s("That’s all folks for Vuex and types without TypeScript. If you have question about it, you can reach me on Twitter ("),e("a",{href:"//twitter.com/znck0"},"@znck0"),s(").")],-1))],64)}const C=r(I,[["render",A],["__file","2018-11-20-type-vuex.md"]]);export{C as default,n as pageData};

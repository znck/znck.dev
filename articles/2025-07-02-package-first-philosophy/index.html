<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Package-First Philosophy | Rahul Kadyan</title>
    <meta name="description" content="A year ago, we were facing a common challenge: a sprawling codebase where everything was interconnected. Fixing one issue often broke something else. Refactors felt like high-stakes operations. Code reviews were slow and confusing because no one was clear on ownership. It was a familiar problem, and it was draining.">
    <link rel="icon" type="image/x-icon" href="https://znck.dev/_assets/favicon-Bdf8E-7X.png">
    <link rel="alternate" type="text/markdown" href="https://znck.dev/articles/2025-07-02-package-first-philosophy.md"><link rel="canonical" href="https://znck.dev/articles/2025-07-02-package-first-philosophy"><link rel="alternate" type="application/atom+xml" href="https://znck.dev/atom.xml"><link rel="alternate" type="application/rss+xml" href="https://znck.dev/rss.xml">
    <script type="module" crossorigin src="https://znck.dev/index.mjs"></script>
    <link rel="stylesheet" crossorigin href="https://znck.dev/_assets/index-BnL0Unmx.css">
  </head>
  <body>
    <div id="app"><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><a class="hidden" href="#content">Skip to content</a><header class="site-header"><nav aria-label="Primary navigation"><a href="/">Home</a></nav></header><main id="content"><article><!--[--><!--[--><h1 id="package-first-philosophy"><a tabindex="-1" href="#package-first-philosophy"><span class="icon icon-link"></span></a>Package-First Philosophy</h1><p>A year ago, we were facing a common challenge: a sprawling codebase where everything was interconnected. Fixing one issue often broke something else. Refactors felt like high-stakes operations. Code reviews were slow and confusing because no one was clear on ownership. It was a familiar problem, and it was draining.</p><p>We decided to change that—not just with better tooling, but by reshaping the way we thought about code.</p><p>So we made a simple bet: <strong>make packages the center of the universe</strong>.</p><h2 id="why-package-first"><a tabindex="-1" href="#why-package-first"><span class="icon icon-link"></span></a>Why Package-First?</h2><p>If something deserves a name, it deserves a package.</p><p>In our world, a package is a unit of structure, ownership, and contribution. It owns its code, tests, documentation, and public interface. It’s a contract—not just to the system, but to the team maintaining it.</p><p>This model provides several benefits:</p><ul><li><strong>Isolation</strong>: Changes in one package stay within that package.</li><li><strong>Ownership</strong>: Contributors are responsible for specific, focused units.</li><li><strong>Autonomy</strong>: You don’t need to coordinate across teams to ship new features.</li><li><strong>Composability</strong>: Small components can be combined to create larger systems.</li><li><strong>Focus</strong>: The smaller the surface area, the easier it is to reason about.</li></ul><p>The side effect? Simpler code, fewer arguments, faster reviews, and clearer responsibilities.</p><h2 id="habits-triggers-and-code"><a tabindex="-1" href="#habits-triggers-and-code"><span class="icon icon-link"></span></a>Habits, Triggers, and Code</h2><p>While reading <em>The Power of Habit</em> by Charles Duhigg, one idea stood out: habits are built on cues, routines, and rewards. Change the cue, and the routine often follows.</p><p>That resonated with our experience.</p><p>Once we made it easy to create a new package—just a few keystrokes and a scaffolded module was ready—developers started defaulting to it. The friction was gone. The cue shifted: instead of asking &quot;where should I add this code?&quot;, the new instinct became &quot;should I create a new package for this?&quot;</p><p>The result? A new habit. Modular thinking became automatic. Developers started creating focused packages, with clear interfaces and isolated tests. The reward was immediate: fewer merge conflicts, faster reviews, and a deeper sense of ownership.</p><p>As Duhigg puts it, once a habit loop is established, it reinforces itself. The package-first mindset became that loop.</p><h2 id="enabling-package-first-development"><a tabindex="-1" href="#enabling-package-first-development"><span class="icon icon-link"></span></a>Enabling Package-First Development</h2><p>Making package creation easy was a game-changer. Teams stopped overloading existing modules and started creating new packages instead. The monolith didn’t shrink, but it became much more understandable.</p><p>We used Nx and pnpm to implement this, but the tools were just the means to an end. Here’s what we focused on:</p><ul><li><strong>Nx generators</strong>: These scaffold fully functional packages for known types—<code>utility</code>, <code>tool</code>, <code>feature</code>, or <code>app</code>. Each package comes with build, test, lint, and documentation preconfigured.</li><li><strong>Ready-to-use packages</strong>: No extra setup required. Just start writing code.</li><li><strong>Explicit public interfaces</strong>: All public interfaces are clearly marked with <code>@public</code>, and we enforce this through tooling.</li></ul><p>As friction disappeared, hesitation followed suit. Developers iterated faster, experimented more, and by default, wrote more modular code.</p><h2 id="metadata-is-ownership"><a tabindex="-1" href="#metadata-is-ownership"><span class="icon icon-link"></span></a>Metadata is Ownership</h2><p>Every package clearly defines its owner, where to file bugs, and what it does. But the real power is in the metadata: the <code>package.json</code> often tells you more than the code itself. It communicates intent, capabilities, and responsibilities—all without opening a single <code>.ts</code> file.</p><p>Here’s how it works:</p><ul><li><strong>Ownership metadata</strong> drives the routing of code reviews, ensuring that the right people are involved.</li><li><strong>Capability metadata</strong> enables feature discovery and helps developers understand what each package is responsible for.</li><li><strong>Dependency metadata</strong> powers impact analysis, letting you know how changes will affect other parts of the codebase.</li></ul><p>This isn’t just documentation—it’s operational infrastructure. By treating packages as self-describing units, we gain confidence across the board, and this structure supports automated tooling and decision-making.</p><h2 id="scale-by-design"><a tabindex="-1" href="#scale-by-design"><span class="icon icon-link"></span></a>Scale by Design</h2><p>When everything is a package:</p><ul><li>Teams onboard faster because they understand exactly where to find and contribute to code.</li><li>Features become portable, easily shared and reused.</li><li>Applications become compositions rather than monolithic systems.</li><li>Dependencies stay local, reducing complexity and risk.</li></ul><p>It’s not magic—it’s just structure. And structure scales.</p><p>In the first six months, we saw over 80 new packages created, many by teams who had never worked in this repo before. That wasn’t just a win for tooling—it was a shift in how people thought about software: small, manageable units, clear contracts, and fast feedback.</p><p>As we leaned further into the package-first model, it reinforced itself. Better structure led to better habits. Better habits led to better software.</p><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--><!--]--></article></main><!--]--></div>
  </body>
</html>
